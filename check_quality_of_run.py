import argparse
from os import path
import smtplib

"""
This script is intended to analyse the output from the pipeline.name and
check if a certain percentage of samples have passed our coverage control.
The script takes the csv file generated by pipeline.name and runs some summary statistics.
The resulting data is written to an outfile located in the folder specified by the user.
If a certain percentage of failed samples of an origin is above a set up threshold (default 10%)
an email will be sent containing a warning.
"""

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('-i','--infile', required=True, help='The quality infile. Should be gives as "," separated file')
    parser.add_argument('-o','--outdir', default='./', help='The directory in which the outout will be stored')
    parser.add_argument('-c','--cutoff', default=10, type=float, help='Maximum percentage of failed samples')
    options = parser.parse_args()

    origin_analysis_info_dict = parse_quality_file(options.infile)
    origin_stats_dict = count_failed_samples(origin_analysis_info_dict)

    basename = '.'.join(options.infile.split('/')[-1].split('.')[0:-1]) # Extract the filename
    outfile = f'{path.abspath(options.outdir)}/{basename}_origin_statistics.txt' # Create an outfile based on the infile name

    message, got_a_fail = check_numbers(origin_stats_dict, outfile, options.cutoff, basename)

    # We have at least one origin with % of failed samples above threshold
    if got_a_fail:
        send_notification(message, "localhost","receiving@email.com")

def send_notification(message, sender, receiver):
    """
    This function will send an email to specified receivers containing 
    information that too manye samples from origin X and Y have failed the coverage cutoff
    """
    print(message)
    

def check_numbers(origin_stats_dict, outfile, cutoff, basename):
    """
    Takes a dictionary with origin as keys and summary statistics for the origin as input.
    Writes an output file containing information about the quality for each origin
    """
    # Create a warning message that will be sent if any of the origins num fails are above 10%
    message = f'Warning, the following origins from run {basename} resulted in more than {cutoff}% failed samples\n'
    got_a_fail = False
    
    fout = open(outfile,'w') # Open outfile
    fout.write('Origin,num_samples,perc_pass,perc_fail,status\n')
    for origin, info in origin_stats_dict.items():
        num_samples = info['num_samples']
        perc_pass = info['perc_pass']
        perc_fail = info['perc_fail']
        if perc_fail > cutoff:
            status = 'Fail'
            got_a_fail = True
            message = f'{message}origin: {origin}, num_samples: {num_samples}, perc_fail: {perc_fail:.2f}\n'
        else:
            status = 'OK'
        fout.write(f'{origin},{num_samples},{perc_pass:.2f},{perc_fail:.2f},{status}\n')
    return message, got_a_fail

def count_failed_samples(origin_analysis_info_dict):
    """
    Takes a dictionary containing origins as keys and
    quality control status (0/1) as a list for each origin.
    Calculates the summary statistics as number of samples, number and percentage of fail and pass.
    Returns a dictionary with origins as keys and the summary statics as a dictionary within
    """
    origin_stats_dict = {}
    for origin, info in origin_analysis_info_dict.items():
        qc_status = info['qc_pass'] # Extract the list containig qc_info for this origin
        # Get the summary statistics: number of samples, number and percentage of passes, and number and percentage of fails
        num_samples = len(qc_status)
        num_pass = sum(qc_status)
        perc_pass = float(num_pass)/float(num_samples)*100
        num_fail = num_samples - num_pass
        perc_fail = float(num_fail)/float(num_samples)*100
        
        tmp = {} # create an empty dictionary
        tmp['num_samples'] = num_samples
        tmp['num_pass'] = num_pass
        tmp['perc_pass'] = perc_pass
        tmp['num_fail'] = num_fail
        tmp['perc_fail'] = perc_fail
        
        origin_stats_dict[origin] = tmp # populate the origin dictionary with the summary statistics
    return origin_stats_dict


def parse_quality_file(qc_infile):
    """
    Takes a quality file in csv format as input and saves the
    information in a dictionary with the sample origin as keys.
    The sample should contain six columns.
    """
    origin_analysis_info_dict = {}
    first = True
    with open(qc_infile) as f:
        for line in f:
            line = line.strip().split(',')
            if first: # Check if first line
                column_names = line # Save the categories.
                first = False
            else:
                # Get the origin of this sample.
                # Assumes that the origin X is denoted as the second letter 
                # in  DX-00000
                origin = line[0].split('-')[0][1]
                
                qc_pass = line[5].lower() # Make sure that we only have lowercase letters
                
                # Encode the qc pass status to binary for easier comparison down the line
                if qc_pass == 'true':
                    qc_pass = 1
                else:
                    qc_pass = 0
                
                # Save qc_pass information in a dictionary with origin as keys
                if not origin in origin_analysis_info_dict:
                    origin_analysis_info_dict[origin] = {} # We use a dictionary here so that we in the future more easily can extend the base dictionary with more information
                    origin_analysis_info_dict[origin]['qc_pass'] = [qc_pass]
                else:
                    origin_analysis_info_dict[origin]['qc_pass'].append(qc_pass)
    return origin_analysis_info_dict

if __name__=='__main__':
    main()
